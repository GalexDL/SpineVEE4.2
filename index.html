<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>SpineVee 4.2</title>
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico">
    <script src="./assets/pixi.min.js"></script>
    <script src="./assets/spine-pixi-v8.js"></script>
    <script src="./assets/lil-gui.umd.min.js"></script>
    <link href="./assets/lil-gui.min.css" rel="stylesheet">
    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      
      .github-corner {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 9999;
        width: 50px;
        height: 50px;
        background-color: #24292e;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.3s ease, background-color 0.3s ease;
        text-decoration: none;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      }
      
      .github-corner:hover {
        background-color: #6e40c9;
        transform: scale(1.1);
      }
      
      .github-corner svg {
        width: 28px;
        height: 28px;
        fill: white;
      }

      /* Custom file upload styles */
      #customFileInput {
        display: none;
      }
      .drop-overlay {
        display: none;
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(44, 62, 80, 0.85);
        z-index: 10000;
        align-items: center;
        justify-content: center;
        pointer-events: none;
      }
      .drop-overlay.active {
        display: flex;
      }
      .drop-overlay-inner {
        border: 3px dashed rgba(255,255,255,0.6);
        border-radius: 16px;
        padding: 48px 64px;
        text-align: center;
        color: #fff;
        font-family: sans-serif;
      }
      .drop-overlay-inner h2 {
        margin: 0 0 8px;
        font-size: 24px;
        font-weight: 600;
      }
      .drop-overlay-inner p {
        margin: 0;
        font-size: 14px;
        opacity: 0.7;
      }
    </style>
  </head>

  <body>
    <input type="file" id="customFileInput" multiple accept=".atlas,.skel,.json,.png,.webp">
    <div class="drop-overlay" id="dropOverlay">
      <div class="drop-overlay-inner">
        <h2>Drop Spine Files Here</h2>
        <p>.atlas + .skel/.json + .png textures</p>
      </div>
    </div>
    <a href="https://github.com/GalexDL/SpineVEE4.2" target="_blank" class="github-corner" title="View on GitHub">
      <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
      </svg>
    </a>
    <div style="display: none;">
      <p>Postion X</p>
      <input class="uk-input" type="number" min="0.01" step="1.00" id="optionX">
      <p>Postion Y</p>
      <input class="uk-input" type="number" min="0.01" step="1.00" id="optionY">
      <button onclick="skindebug()"></button>
    </div>


    <div class="uk-width-1-1" style="display: none;">
      <p><label><input class="uk-checkbox" type="checkbox" id="optionAutoPos" checked> Auto Centerize</label></p>
    </div>

    <script>
      let spineboy;
      let currentModelIndex = 0;
      let app;
      let models = []; // models.json
      let params = {
        scale: 1.00,
        posx: 0,
        posy: 0,
        rotation: 0,
        exportScaleFactor: 1,
        loop: true,
        backgroundColor: '#2c3e50',
      };
      let myObject = {
        time: 0,
        myNumber: 1
      };
      let prevValue = myObject.time;

      async function loadCustomModel(files) {
        const filesByExt = {};
        for (const file of files) {
          const ext = file.name.split('.').pop().toLowerCase();
          if (!filesByExt[ext]) filesByExt[ext] = [];
          filesByExt[ext].push(file);
        }

        const atlasFiles = filesByExt['atlas'] || [];
        const skelFiles = filesByExt['skel'] || [];
        const jsonFiles = filesByExt['json'] || [];
        const pngFiles = filesByExt['png'] || [];

        const atlasFile = atlasFiles[0];
        const dataFile = skelFiles[0] || jsonFiles[0];

        if (!atlasFile) {
          alert('Missing .atlas file. Please select at least a .atlas file and a .skel or .json skeleton file, plus texture .png files.');
          return null;
        }
        if (!dataFile) {
          alert('Missing skeleton file. Please select a .skel or .json skeleton data file.');
          return null;
        }

        // Load PNG and WebP textures into SpineTexture objects
        const textureMap = {};
        const imageFiles = [...pngFiles, ...(filesByExt['webp'] || [])];
        for (const imageFile of imageFiles) {
          const blobUrl = URL.createObjectURL(imageFile);
          const img = new Image();
          img.src = blobUrl;
          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
          });
          URL.revokeObjectURL(blobUrl);
          const source = new PIXI.ImageSource({ resource: img });
          textureMap[imageFile.name] = spine.SpineTexture.from(source);
        }

        // Parse atlas text and assign textures to pages
        const atlasText = await atlasFile.text();
        const textureAtlas = new spine.TextureAtlas(atlasText);
        const textureLayers = textureAtlas.pages;
        const missingTextureLayers = [];
        for (const textureLayer of textureLayers) {
          const tex = textureMap[textureLayer.name];
          if (tex) {
            textureLayer.setTexture(tex);
          } else {
            missingTextureLayers.push(textureLayer.name);
          }
        }
        if (missingTextureLayers.length > 0) {
          alert('Missing texture(s) referenced by the atlas: ' + missingTextureLayers.join(', ') + '\nPlease include the .png or .webp file(s).');
          return null;
        }

        // Parse skeleton data
        const attachmentLoader = new spine.AtlasAttachmentLoader(textureAtlas);
        let skeletonData;
        if (dataFile.name.toLowerCase().endsWith('.skel')) {
          const buffer = await dataFile.arrayBuffer();
          const parser = new spine.SkeletonBinary(attachmentLoader);
          skeletonData = parser.readSkeletonData(new Uint8Array(buffer));
        } else {
          const text = await dataFile.text();
          const jsonData = JSON.parse(text);
          const parser = new spine.SkeletonJson(attachmentLoader);
          skeletonData = parser.readSkeletonData(jsonData);
        }

        // Create Spine display object
        const spineObj = new spine.Spine({ skeletonData });
        spineObj.state.data.defaultMix = 0.2;
        spineObj.x = window.innerWidth / 2;
        spineObj.y = window.innerHeight / 2;

        params.scale = 1.00;
        params.posx = spineObj.x;
        params.posy = spineObj.y;

        if (spineObj.skeleton.data.animations.length > 0) {
          spineObj.state.setAnimation(0, spineObj.skeleton.data.animations[0].name, params.loop);
        }

        return spineObj;
      }

      async function loadModel(modelIndex) {
        const currentModel = models[modelIndex];
        
        // Use unique ids for each model to avoid caching issues
        const dataAlias = `model_${modelIndex}_data`;
        const atlasAlias = `model_${modelIndex}_atlas`;
        
        // Pre-load the skeleton data and atlas
        PIXI.Assets.add({alias: dataAlias, src: currentModel.data});
        PIXI.Assets.add({alias: atlasAlias, src: currentModel.atlas});
        await PIXI.Assets.load([dataAlias, atlasAlias]);

        // Create the spine objectdata
        spineboy = spine.Spine.from({
          skeleton: dataAlias,
          atlas: atlasAlias,
          scale: 1,
        });

        // Set the default mix time
        spineboy.state.data.defaultMix = 0.2;

        // Center the spine object on screen
        spineboy.x = window.innerWidth / 2;
        spineboy.y = window.innerHeight / 2;

        // Reset parameters
        params.scale = 1.00;
        params.posx = spineboy.x;
        params.posy = spineboy.y;

        // Play first animation on startup
        if (spineboy.skeleton.data.animations.length > 0) {
            const firstAnimationName = spineboy.skeleton.data.animations[0].name;
            spineboy.state.setAnimation(0, firstAnimationName, params.loop);
        }

        return spineboy;
      }

      (async function initializeApp() {
        // Load models list from json file
        const response = await fetch('assets/models.json');
        models = await response.json();

        app = new PIXI.Application();
        await app.init({
          width: window.innerWidth,
          height: window.innerHeight,
          resolution: window.devicePixelRatio || 1,
          autoDensity: true,
          resizeTo: window,
          backgroundColor: 0x2c3e50,
          hello: true,
        })
        app.renderer.background.alpha = 1;
        app.view.id = "screen";
        document.body.appendChild(app.view);

        // Load the first model
        spineboy = await loadModel(0);
        app.stage.addChild(spineboy);

        //Model Selection
        const gui = new lil.GUI({});
        const modelNames = models.map(m => m.name);
        const objAnimm = { Model: modelNames[0] }

        const modelController = gui
        .add(objAnimm, 'Model', modelNames)
          .onChange(async (value) => {
            const newIndex = models.findIndex(m => m.name === value);
            if (newIndex < 0 || !models[newIndex].data) {
              // Custom model entry â€” can only be loaded via file picker
              return;
            }
            currentModelIndex = newIndex;
            
            // Remove old model and load new one
            app.stage.removeChild(spineboy);
            spineboy = await loadModel(newIndex);
            app.stage.addChild(spineboy);
            
            // Populate Skins
            const newSkinNames = spineboy.skeleton.data.skins.map(skin => skin.name);
            objSkin.Skin = newSkinNames[0];
            skinController.options(newSkinNames);
            skinController.updateDisplay();
            
            // Populate Animations
            const newAnimNames = spineboy.skeleton.data.animations.map(anim => anim.name);
            objAnim.Animation = newAnimNames[0];
            animController.options(newAnimNames);
            animController.updateDisplay();
            
            // Update timeline for new animation
            updateTimelineRange();
            
            // Reset controllers to reflect new model's position
            posxController.updateDisplay();
            posyController.updateDisplay();
            scaleController.updateDisplay();
          });

        // 'Load Custom Model' button under the model selector (remember plz plz plz)
        modelController.parent.add({
          loadCustom: () => {
            document.getElementById('customFileInput').click();
          }
        }, 'loadCustom').name('\u{1F4C1} Load Custom Model');

        //Model 1
        const folderModel1 = gui.addFolder( 'Base Model' );
        const folderTransform = folderModel1.addFolder( 'Transformation' );
        const folderStyle = folderModel1.addFolder( 'Style' );
        const folderExport = folderModel1.addFolder( 'Export' );

        ///////////////////
        //Transformation
        ///////////////////

        //Scale
        const scaleController = folderTransform
          .add(params, 'scale', 0.0, 5.0).step(0.01)
          .onChange(() => {
            spineboy.scale.x = spineboy.scale.y = Math.max(params.scale, 0);
          });
        ///////////////////
        //Position X
        const posxController = folderTransform
          .add(params, 'posx', -2000.0, 2000.0).step(1.00)
          .onChange(() => {
            spineboy.x = params.posx;
            params.posx = spineboy.x;
            posxController.updateDisplay();
        });
        ///////////////////
        //Position Y
        const posyController = folderTransform
          .add(params, 'posy', -2000.0, 2000.0).step(1.00)
          .onChange(() => {
            spineboy.y = params.posy;
            params.posy = spineboy.y;
            posyController.updateDisplay();
        });
        ///////////////////
        //Rotation
        const rotationController = folderTransform
          .add(params, 'rotation', 0, 360).step(1.00)
          .name('Rotation (degrees)')
          .onChange(() => {
            spineboy.rotation = (params.rotation * Math.PI) / 180;
          });

        /////////////////////////////////////
        //Style
        //////////////////////////////////////
        
        // Background Color
        folderStyle
          .addColor(params, 'backgroundColor')
          .name('Background Color')
          .onChange((value) => {
            const colorNumber = parseInt(value.replace('#', ''), 16);
            app.renderer.background.color = colorNumber;
          });
        
        //Skins
        const skinNames = spineboy.skeleton.data.skins.map(skin => skin.name);
        objSkin = { Skin: skinNames[0] || 'default'}
        const skinController = folderStyle
          .add( objSkin, 'Skin', skinNames )
          .onChange((value) => {
            spineboy.skeleton.setSkinByName(value);
            spineboy.skeleton.setSlotsToSetupPose();
          });

        //Animation
        objAnim = { Animation: spineboy.skeleton.data.animations.length > 0 ? spineboy.skeleton.data.animations[0].name : 'idle'}
        const animationNames = spineboy.skeleton.data.animations.map(anim => anim.name);
        
        // Play/Pause state
        let isPlaying = false;
        const playbackControl = { 
          'First Frame': () => {
            myObject.time = 0;
            animTimeController.updateDisplay();
            if (spineboy.state.tracks[0]) {
              spineboy.state.tracks[0].trackTime = 0;
              spineboy.state.tracks[0].timeScale = 0;
              isPlaying = false;
            }
          },
          'Play/Pause': () => {
            isPlaying = !isPlaying;
            if (spineboy.state.tracks[0]) {
              if (isPlaying) {
                spineboy.state.tracks[0].timeScale = 1;
              } else {
                spineboy.state.tracks[0].timeScale = 0;
              }
            }
          },
          'Last Frame': () => {
            const currentAnim = spineboy.skeleton.data.findAnimation(objAnim.Animation);
            if (currentAnim && spineboy.state.tracks[0]) {
              myObject.time = currentAnim.duration;
              animTimeController.updateDisplay();
              spineboy.state.tracks[0].trackTime = currentAnim.duration;
              spineboy.state.tracks[0].timeScale = 0;
              isPlaying = false;
            }
          }
        };
        
        // Frame sparking track
        function updateTimelineRange() {
          const currentAnim = spineboy.skeleton.data.findAnimation(objAnim.Animation);
          if (currentAnim) {
            myObject.time = 0;
            animTimeController.max(currentAnim.duration);
            animTimeController.updateDisplay();
          }
        }
        
        const animController = folderStyle
          .add(objAnim, 'Animation', animationNames)
          .onChange((value) => {
            spineboy.state.setAnimation(0, value, params.loop);
            isPlaying = false; // Pause when changing animations
            updateTimelineRange();
          });
        
        // Loop toggle
        folderStyle
          .add(params, 'loop')
          .name('Loop Animation')
          .onChange((value) => {
            if (spineboy.state.tracks[0]) {
              spineboy.state.tracks[0].loop = value;
            }
          });
        
        // Playback controls
        folderStyle.add(playbackControl, 'First Frame');
        folderStyle.add(playbackControl, 'Play/Pause');
        folderStyle.add(playbackControl, 'Last Frame');
        
        //Timeline 
        const animTimeController = folderStyle
        .add(myObject, 'time').min(0).max(spineboy.skeleton.data.animations[0].duration).step(0.001)
          .name( 'Animation Time' )
          .onChange(value => {
            // Set to specific time
            if (spineboy.state.tracks[0]) {
              spineboy.state.tracks[0].trackTime = value;
              if (!isPlaying) {
                spineboy.state.tracks[0].timeScale = 0; // Keep paused if not playing
              }
            }
          });
        
        updateTimelineRange();
        /////////////////////////////////





        ////////////////////////
        // Recording (lol)
        ////////////////////////


        ////////////////////////
        // Screenshot button
        ////////////////////////
        
        folderExport.add({
          takeScreenshotLow: async () => {
            const scaleFactor = params.exportScaleFactor;
            const origWidth = app.renderer.width;
            const origHeight = app.renderer.height;
            const origResolution = app.renderer.resolution;

            // temp resize for higher resolution 
            app.renderer.resolution = 1;
            app.renderer.resize(origWidth * scaleFactor, origHeight * scaleFactor);
            
            // lock scale to 1.0 for export, only apply resolution scale factor, becuase the bigger the more pain 
            const oldScaleX = spineboy.scale.x;
            const oldScaleY = spineboy.scale.y;
            const oldX = spineboy.x;
            const oldY = spineboy.y;
            spineboy.scale.x = scaleFactor;
            spineboy.scale.y = scaleFactor;
            spineboy.x *= scaleFactor;
            spineboy.y *= scaleFactor;

            // Render and extract at higher resolution
            app.renderer.render(app.stage);
            const image = await app.renderer.extract.image(app.stage);
            
            // create download link
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.download = `spinevee-export-${timestamp}.png`;
            link.href = image.src;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // restore original size and scale
            spineboy.scale.x = oldScaleX;
            spineboy.scale.y = oldScaleY;
            spineboy.x = oldX;
            spineboy.y = oldY;
            app.renderer.resize(origWidth, origHeight);
            app.renderer.resolution = origResolution;
            app.renderer.render(app.stage);
          }
        }, 'takeScreenshotLow').name('ðŸ“· Export as PNG');

        // Export scale factor slider
        folderExport.add(params, 'exportScaleFactor', 0.1, 2.0).step(0.1).name('Scale Factor');



        /////////////////////////////////////
        //Debug
        //////////////////////////////////////
        
        // Handle custom file selection
        document.getElementById('customFileInput').addEventListener('change', async (e) => {
          if (!e.target.files || e.target.files.length === 0) return;
          try {
            const newSpine = await loadCustomModel(e.target.files);
            if (!newSpine) return;
            app.stage.removeChild(spineboy);
            spineboy = newSpine;
            app.stage.addChild(spineboy);

            // Update Model dropdown to show custom name
            const customName = 'Custom Model';
            if (!models.find(m => m.name === customName)) {
              models.push({ name: customName, data: '', atlas: '' });
              const newModelNames = models.map(m => m.name);
              modelController.options(newModelNames);
            }
            objAnimm.Model = customName;
            modelController.updateDisplay();

            // Update skins
            const newSkinNames = spineboy.skeleton.data.skins.map(skin => skin.name);
            objSkin.Skin = newSkinNames[0] || 'default';
            skinController.options(newSkinNames);
            skinController.updateDisplay();

            // Update animations
            const newAnimNames = spineboy.skeleton.data.animations.map(anim => anim.name);
            objAnim.Animation = newAnimNames[0];
            animController.options(newAnimNames);
            animController.updateDisplay();

            updateTimelineRange();
            scaleController.updateDisplay();
            posxController.updateDisplay();
            posyController.updateDisplay();
          } catch (err) {
            console.error('Failed to load custom model:', err);
            alert('Failed to load custom model: ' + err.message);
          }
          e.target.value = '';
        });

        // Drag-and-drop support
        const dropOverlay = document.getElementById('dropOverlay');
        let dragCounter = 0;
        document.addEventListener('dragenter', (e) => {
          e.preventDefault();
          dragCounter++;
          dropOverlay.classList.add('active');
        });
        document.addEventListener('dragleave', (e) => {
          e.preventDefault();
          dragCounter--;
          if (dragCounter <= 0) {
            dragCounter = 0;
            dropOverlay.classList.remove('active');
          }
        });
        document.addEventListener('dragover', (e) => {
          e.preventDefault();
        });
        document.addEventListener('drop', async (e) => {
          e.preventDefault();
          dragCounter = 0;
          dropOverlay.classList.remove('active');
          if (!e.dataTransfer.files || e.dataTransfer.files.length === 0) return;
          try {
            const newSpine = await loadCustomModel(e.dataTransfer.files);
            if (!newSpine) return;
            app.stage.removeChild(spineboy);
            spineboy = newSpine;
            app.stage.addChild(spineboy);

            const customName = 'Custom Model';
            if (!models.find(m => m.name === customName)) {
              models.push({ name: customName, data: '', atlas: '' });
              const newModelNames = models.map(m => m.name);
              modelController.options(newModelNames);
            }
            objAnimm.Model = customName;
            modelController.updateDisplay();

            const newSkinNames = spineboy.skeleton.data.skins.map(skin => skin.name);
            objSkin.Skin = newSkinNames[0] || 'default';
            skinController.options(newSkinNames);
            skinController.updateDisplay();

            const newAnimNames = spineboy.skeleton.data.animations.map(anim => anim.name);
            objAnim.Animation = newAnimNames[0];
            animController.options(newAnimNames);
            animController.updateDisplay();

            updateTimelineRange();
            scaleController.updateDisplay();
            posxController.updateDisplay();
            posyController.updateDisplay();
          } catch (err) {
            console.error('Failed to load custom model:', err);
            alert('Failed to load dropped model: ' + err.message);
          }
        });

        // Converter link button
        gui.add({ 
          openConverter: () => {
            window.open('https://github.com/wang606/SpineSkeletonDataConverter', '_blank');
          }
        }, 'openConverter').name('Spine Converter Tool');
        // version
        gui.add({ changeModel: () => {
            const currentModel = models[currentModelIndex];
            console.log("Version: 4.0 (Finally Figured Out BLOBs, aka you can now import custom models without hosting them, just select the files or drag and drop them in!)");
            console.log("Json:", currentModel.data);
            console.log("Atlas:", currentModel.atlas);
        }}, 'changeModel').name('Debug');

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ///////////////////////
        // Draggable Canvas
        ///////////////////////
        let canvasScreen = document.getElementById("screen");
        console.log("Before accessing canvasScreen:", canvasScreen);
        console.log("After accessing canvasScreen:", canvasScreen);
        let isDragging = false;
        let canMouseX, canMouseY;
        let initMouseX, initMouseY;
        let canvasX, canvasY;

        canvasScreen.addEventListener("mousedown", handleMouseDown);
        canvasScreen.addEventListener("mouseup", handleMouseUp);
        canvasScreen.addEventListener("mouseout", handleMouseOut);
        canvasScreen.addEventListener("mousemove", handleMouseMove);

        canvasScreen.addEventListener("touchstart", handleTouchStart);
        canvasScreen.addEventListener("touchend", handleTouchEnd);
        canvasScreen.addEventListener("touchmove", handleTouchMove);
        canvasScreen.addEventListener("wheel", handleWheel);

        function handleWheel(e) {
            e.preventDefault();
            // deltaY is positive when scrolling down, negative when scrolling up
            const zoomSpeed = 0.001;
            const delta = -e.deltaY * zoomSpeed;
            
            params.scale = Math.max(0.1, Math.min(5.0, params.scale + delta));
            spineboy.scale.x = spineboy.scale.y = params.scale;
            scaleController.updateDisplay();
        }

        function handleMouseDown(e) {
            e.preventDefault();
            window.startX = spineboy.x;
            window.startY = spineboy.y;
            window.startMouseX = e.clientX;
            window.startMouseY = e.clientY;
            window.isDragging = true;
        }

        function handleMouseUp(e) {
            window.isDragging = false;
        }

        function handleMouseOut(e) {
            window.isDragging = false;
        }

        function handleMouseMove(e) {
            if (window.isDragging) {
                const deltaX = e.clientX - window.startMouseX;
                const deltaY = e.clientY - window.startMouseY;
                
                spineboy.x = window.startX + deltaX;
                spineboy.y = window.startY + deltaY;
                
                params.posx = spineboy.x;
                params.posy = spineboy.y;

                posxController.updateDisplay();
                posyController.updateDisplay();
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            
            if (e.touches.length === 2) {
                // Pinch zoom starting
                window.isPinching = true;
                window.isDragging = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                window.initialPinchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                window.initialScale = params.scale;
            } else if (e.touches.length === 1) {
                // Single touch for dragging
                window.isPinching = false;
                window.startX = spineboy.x;
                window.startY = spineboy.y;
                window.startMouseX = e.touches[0].clientX;
                window.startMouseY = e.touches[0].clientY;
                window.isDragging = true;
            }
        }

        function handleTouchEnd(e) {
            if (e.touches.length < 2) {
                window.isPinching = false;
            }
            if (e.touches.length === 0) {
                window.isDragging = false;
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 2 && window.isPinching) {
                // Pinch zoom
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                const scaleChange = currentDistance / window.initialPinchDistance;
                params.scale = Math.max(0.1, Math.min(5.0, window.initialScale * scaleChange));
                spineboy.scale.x = spineboy.scale.y = params.scale;
                scaleController.updateDisplay();
            } else if (e.touches.length === 1 && window.isDragging && !window.isPinching) {
                // Single touch dragging
                const deltaX = e.touches[0].clientX - window.startMouseX;
                const deltaY = e.touches[0].clientY - window.startMouseY;
                
                spineboy.x = window.startX + deltaX;
                spineboy.y = window.startY + deltaY;
                
                params.posx = spineboy.x;
                params.posy = spineboy.y;
                
                posxController.updateDisplay();
                posyController.updateDisplay();
            }
        }

      })();



    </script>
  </body>
</html>