<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>SpineVee 4.2</title>
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico">
    <script src="./assets/pixi.min.js"></script>
    <script src="./assets/spine-pixi-v8.js"></script>
    <script src="./assets/lil-gui.umd.min.js"></script>
    <link href="./assets/lil-gui.min.css" rel="stylesheet">
    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      
      .github-corner {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 9999;
        width: 50px;
        height: 50px;
        background-color: #24292e;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.3s ease, background-color 0.3s ease;
        text-decoration: none;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      }
      
      .github-corner:hover {
        background-color: #6e40c9;
        transform: scale(1.1);
      }
      
      .github-corner svg {
        width: 28px;
        height: 28px;
        fill: white;
      }
    </style>
  </head>

  <body>
    <a href="https://github.com/GalexDL/SpineVEE4.2" target="_blank" class="github-corner" title="View on GitHub">
      <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
      </svg>
    </a>
    <div style="display: none;">
      <p>Postion X</p>
      <input class="uk-input" type="number" min="0.01" step="1.00" id="optionX">
      <p>Postion Y</p>
      <input class="uk-input" type="number" min="0.01" step="1.00" id="optionY">
      <button onclick="skindebug()"></button>
    </div>


    <div class="uk-width-1-1" style="display: none;">
      <p><label><input class="uk-checkbox" type="checkbox" id="optionAutoPos" checked> Auto Centerize</label></p>
    </div>

    <script>
      let spineboy;
      let currentModelIndex = 0;
      let app;
      let models = []; // models.json
      let params = {
        scale: 1.00,
        posx: 0,
        posy: 0,
        loop: true,
        backgroundColor: '#2c3e50',
        framerate: 60,
      };
      let myObject = {
        time: 0,
        myNumber: 1
      };
      let prevValue = myObject.time;

      async function loadModel(modelIndex) {
        const currentModel = models[modelIndex];
        
        // Use unique ids for each model to avoid caching issues
        const dataAlias = `model_${modelIndex}_data`;
        const atlasAlias = `model_${modelIndex}_atlas`;
        
        // Pre-load the skeleton data and atlas
        PIXI.Assets.add({alias: dataAlias, src: currentModel.data});
        PIXI.Assets.add({alias: atlasAlias, src: currentModel.atlas});
        await PIXI.Assets.load([dataAlias, atlasAlias]);

        // Create the spine objectdata
        spineboy = spine.Spine.from({
          skeleton: dataAlias,
          atlas: atlasAlias,
          scale: 1,
        });

        // Set the default mix time
        spineboy.state.data.defaultMix = 0.2;

        // Center the spine object on screen
        spineboy.x = window.innerWidth / 2;
        spineboy.y = window.innerHeight / 2;

        // Reset parameters
        params.scale = 1.00;
        params.posx = spineboy.x;
        params.posy = spineboy.y;

        // Play first animation on startup
        if (spineboy.skeleton.data.animations.length > 0) {
            const firstAnimationName = spineboy.skeleton.data.animations[0].name;
            spineboy.state.setAnimation(0, firstAnimationName, params.loop);
        }

        return spineboy;
      }

      (async function initializeApp() {
        // Load models list from json file
        const response = await fetch('assets/models.json');
        models = await response.json();

        app = new PIXI.Application();
        await app.init({
          width: window.innerWidth,
          height: window.innerHeight,
          resolution: window.devicePixelRatio || 1,
          autoDensity: true,
          resizeTo: window,
          backgroundColor: 0x2c3e50,
          hello: true,
        })
        app.view.id = "screen";
        document.body.appendChild(app.view);

        // Load the first model
        spineboy = await loadModel(0);
        app.stage.addChild(spineboy);

        //Model Selection
        const gui = new lil.GUI({});
        const modelNames = models.map(m => m.name);
        const objAnimm = { Model: modelNames[0] }

        gui
        .add(objAnimm, 'Model', modelNames)
          .onChange(async (value) => {
            const newIndex = models.findIndex(m => m.name === value);
            currentModelIndex = newIndex;
            
            // Remove old model and load new one
            app.stage.removeChild(spineboy);
            spineboy = await loadModel(newIndex);
            app.stage.addChild(spineboy);
            
            // Populate Skins
            const newSkinNames = spineboy.skeleton.data.skins.map(skin => skin.name);
            objSkin.Skin = newSkinNames[0];
            skinController.options(newSkinNames);
            skinController.updateDisplay();
            
            // Populate Animations
            const newAnimNames = spineboy.skeleton.data.animations.map(anim => anim.name);
            objAnim.Animation = newAnimNames[0];
            animController.options(newAnimNames);
            animController.updateDisplay();
            
            // Update timeline for new animation
            updateTimelineRange();
            
            // Reset controllers to reflect new model's position
            posxController.updateDisplay();
            posyController.updateDisplay();
            scaleController.updateDisplay();
          });

        //Model 1
        const folderModel1 = gui.addFolder( 'Base Model' );
        const folderTransform = folderModel1.addFolder( 'Transformation' );
        const folderStyle = folderModel1.addFolder( 'Style' );
        const folderExport = folderModel1.addFolder( 'Export' );

        ///////////////////
        //Transformation
        ///////////////////

        //Scale
        const scaleController = folderTransform
          .add(params, 'scale', 0.0, 5.0).step(0.01)
          .onChange(() => {
            spineboy.scale.x = spineboy.scale.y = Math.max(params.scale, 0);
          });
        ///////////////////
        //Position X
        const posxController = folderTransform
          .add(params, 'posx', -2000.0, 2000.0).step(1.00)
          .onChange(() => {
            spineboy.x = params.posx;
            params.posx = spineboy.x;
            posxController.updateDisplay();
        });
        ///////////////////
        //Position Y
        const posyController = folderTransform
          .add(params, 'posy', -2000.0, 2000.0).step(1.00)
          .onChange(() => {
            spineboy.y = params.posy;
            params.posy = spineboy.y;
            posyController.updateDisplay();
        });

        /////////////////////////////////////
        //Style
        //////////////////////////////////////
        // Background Color
        folderStyle
          .addColor(params, 'backgroundColor')
          .name('Background Color')
          .onChange((value) => {
            const colorNumber = parseInt(value.replace('#', ''), 16);
            app.renderer.background.color = colorNumber;
          });
        
        //Skins
        const skinNames = spineboy.skeleton.data.skins.map(skin => skin.name);
        objSkin = { Skin: skinNames[0] || 'default'}
        const skinController = folderStyle
          .add( objSkin, 'Skin', skinNames )
          .onChange((value) => {
            spineboy.skeleton.setSkinByName(value);
            spineboy.skeleton.setSlotsToSetupPose();
          });
        //Animation
        objAnim = { Animation: spineboy.skeleton.data.animations.length > 0 ? spineboy.skeleton.data.animations[0].name : 'idle'}
        const animationNames = spineboy.skeleton.data.animations.map(anim => anim.name);
        
        // Play/Pause state
        let isPlaying = false;
        const playbackControl = { 
          'First Frame': () => {
            myObject.time = 0;
            animTimeController.updateDisplay();
            if (spineboy.state.tracks[0]) {
              spineboy.state.tracks[0].trackTime = 0;
              spineboy.state.tracks[0].timeScale = 0;
              isPlaying = false;
            }
          },
          'Play/Pause': () => {
            isPlaying = !isPlaying;
            if (spineboy.state.tracks[0]) {
              if (isPlaying) {
                spineboy.state.tracks[0].timeScale = 1;
              } else {
                spineboy.state.tracks[0].timeScale = 0;
              }
            }
          },
          'Last Frame': () => {
            const currentAnim = spineboy.skeleton.data.findAnimation(objAnim.Animation);
            if (currentAnim && spineboy.state.tracks[0]) {
              myObject.time = currentAnim.duration;
              animTimeController.updateDisplay();
              spineboy.state.tracks[0].trackTime = currentAnim.duration;
              spineboy.state.tracks[0].timeScale = 0;
              isPlaying = false;
            }
          }
        };
        
        // Frame sparking track
        function updateTimelineRange() {
          const currentAnim = spineboy.skeleton.data.findAnimation(objAnim.Animation);
          if (currentAnim) {
            myObject.time = 0;
            animTimeController.max(currentAnim.duration);
            animTimeController.updateDisplay();
          }
        }
        
        const animController = folderStyle
          .add(objAnim, 'Animation', animationNames)
          .onChange((value) => {
            spineboy.state.setAnimation(0, value, params.loop);
            isPlaying = false; // Pause when changing animations
            updateTimelineRange();
          });
        
        // Loop toggle
        folderStyle
          .add(params, 'loop')
          .name('Loop Animation')
          .onChange((value) => {
            if (spineboy.state.tracks[0]) {
              spineboy.state.tracks[0].loop = value;
            }
          });
        
        // Playback controls
        folderStyle.add(playbackControl, 'First Frame');
        folderStyle.add(playbackControl, 'Play/Pause');
        folderStyle.add(playbackControl, 'Last Frame');
        
        //Time Scrubber
        const animTimeController = folderStyle
        .add(myObject, 'time').min(0).max(spineboy.skeleton.data.animations[0].duration).step(0.001)
          .name( 'Animation Time' )
          .onChange(value => {
            // Set to specific time
            if (spineboy.state.tracks[0]) {
              spineboy.state.tracks[0].trackTime = value;
              if (!isPlaying) {
                spineboy.state.tracks[0].timeScale = 0; // Keep paused if not playing
              }
            }
          });
        
        // Initialize timeline range
        updateTimelineRange();
        /////////////////////////////////





        ////////////////////////
        // Recording 
        ////////////////////////
        let isRecording = false;
        let mediaRecorder = null;
        let recordedChunks = [];
        // Framerate 
        folderExport
          .add(params, 'framerate', 10, 120).step(1)
          .name('Video Framerate (FPS)');
        // WEBM Recording button
        folderExport.add({ 
          recordMP4: async () => {
            if (isRecording) {
              console.log('Already recording, please wait...');
              return;
            }
            
            const currentAnim = spineboy.skeleton.data.findAnimation(objAnim.Animation);
            if (!currentAnim) {
              console.error('No animation selected');
              return;
            }
            
            isRecording = true;
            recordedChunks = [];
            const duration = currentAnim.duration;
            
            console.log(`Recording video for ${duration.toFixed(2)} seconds at ${params.framerate} FPS...`);
            
            const canvas = app.view;
            const stream = canvas.captureStream(params.framerate);
            
            let options;
            if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
              options = { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 25000000 };
            } else if (MediaRecorder.isTypeSupported('video/webm')) {
              options = { mimeType: 'video/webm', videoBitsPerSecond: 25000000 };
            } else if (MediaRecorder.isTypeSupported('video/mp4')) {
              options = { mimeType: 'video/mp4', videoBitsPerSecond: 25000000 };
            } else {
              options = { videoBitsPerSecond: 25000000 }; // default codec with high bitrate
            }
            
            mediaRecorder = new MediaRecorder(stream, options);
              
              mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                  recordedChunks.push(event.data);
                }
              };
              
              mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                link.download = `spine-animation-${timestamp}.webm`;
                link.href = url;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                isRecording = false;
                console.log('Video saved!');
              };
              
              // restart animation to start and play
              spineboy.state.setAnimation(0, objAnim.Animation, false);
              spineboy.state.tracks[0].timeScale = 1;
              spineboy.state.tracks[0].trackTime = 0;
              
              // Start recording
              mediaRecorder.start();
              
              // Stop recording after animation duration
              setTimeout(() => {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                  mediaRecorder.stop();
                  if (spineboy.state.tracks[0]) {
                    spineboy.state.tracks[0].timeScale = 0;
                  }
                }
              }, (duration * 1000) + 100); 
          }
        }, 'recordMP4').name('ðŸŽ¬ Record as Video');

        ////////////////////////
        // Screenshot button
        ////////////////////////
        folderExport.add({ 
          takeScreenshot: async () => {
            // Use PIXI's extract to properly capture the rendered stage
            const image = await app.renderer.extract.image(app.stage);
            
            // Create a temporary link element and trigger download
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.download = `spine-screenshot-${timestamp}.png`;
            link.href = image.src;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          }
        }, 'takeScreenshot').name('ðŸ“· Export as PNG');



        /////////////////////////////////////
        //Debug
        //////////////////////////////////////
        
        // Converter link button
        gui.add({ 
          openConverter: () => {
            window.open('https://github.com/wang606/SpineSkeletonDataConverter', '_blank');
          }
        }, 'openConverter').name('Spine Converter Tool');
        gui.add({ changeModel: () => {
            const currentModel = models[currentModelIndex];
            console.log("Version: 3.1 (Skin dynamic pop Fixed, Loop Toggle, Conversion Test, Screenshot & Video Export, Background Picker)");
            console.log("Json:", currentModel.data);
            console.log("Atlas:", currentModel.atlas);
        }}, 'changeModel').name('Debug');

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ///////////////////////
        // Draggable Canvas
        ///////////////////////
        let canvasScreen = document.getElementById("screen");
        console.log("Before accessing canvasScreen:", canvasScreen);
        console.log("After accessing canvasScreen:", canvasScreen);
        let isDragging = false;
        let canMouseX, canMouseY;
        let initMouseX, initMouseY;
        let canvasX, canvasY;

        canvasScreen.addEventListener("mousedown", handleMouseDown);
        canvasScreen.addEventListener("mouseup", handleMouseUp);
        canvasScreen.addEventListener("mouseout", handleMouseOut);
        canvasScreen.addEventListener("mousemove", handleMouseMove);

        canvasScreen.addEventListener("touchstart", handleTouchStart);
        canvasScreen.addEventListener("touchend", handleTouchEnd);
        canvasScreen.addEventListener("touchmove", handleTouchMove);
        canvasScreen.addEventListener("wheel", handleWheel);

        function handleWheel(e) {
            e.preventDefault();
            // deltaY is positive when scrolling down, negative when scrolling up
            const zoomSpeed = 0.001;
            const delta = -e.deltaY * zoomSpeed;
            
            params.scale = Math.max(0.1, Math.min(5.0, params.scale + delta));
            spineboy.scale.x = spineboy.scale.y = params.scale;
            scaleController.updateDisplay();
        }

        function handleMouseDown(e) {
            e.preventDefault();
            window.startX = spineboy.x;
            window.startY = spineboy.y;
            window.startMouseX = e.clientX;
            window.startMouseY = e.clientY;
            window.isDragging = true;
        }

        function handleMouseUp(e) {
            window.isDragging = false;
        }

        function handleMouseOut(e) {
            window.isDragging = false;
        }

        function handleMouseMove(e) {
            if (window.isDragging) {
                const deltaX = e.clientX - window.startMouseX;
                const deltaY = e.clientY - window.startMouseY;
                
                spineboy.x = window.startX + deltaX;
                spineboy.y = window.startY + deltaY;
                
                params.posx = spineboy.x;
                params.posy = spineboy.y;

                posxController.updateDisplay();
                posyController.updateDisplay();
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            
            if (e.touches.length === 2) {
                // Pinch zoom starting
                window.isPinching = true;
                window.isDragging = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                window.initialPinchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                window.initialScale = params.scale;
            } else if (e.touches.length === 1) {
                // Single touch for dragging
                window.isPinching = false;
                window.startX = spineboy.x;
                window.startY = spineboy.y;
                window.startMouseX = e.touches[0].clientX;
                window.startMouseY = e.touches[0].clientY;
                window.isDragging = true;
            }
        }

        function handleTouchEnd(e) {
            if (e.touches.length < 2) {
                window.isPinching = false;
            }
            if (e.touches.length === 0) {
                window.isDragging = false;
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 2 && window.isPinching) {
                // Pinch zoom
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                const scaleChange = currentDistance / window.initialPinchDistance;
                params.scale = Math.max(0.1, Math.min(5.0, window.initialScale * scaleChange));
                spineboy.scale.x = spineboy.scale.y = params.scale;
                scaleController.updateDisplay();
            } else if (e.touches.length === 1 && window.isDragging && !window.isPinching) {
                // Single touch dragging
                const deltaX = e.touches[0].clientX - window.startMouseX;
                const deltaY = e.touches[0].clientY - window.startMouseY;
                
                spineboy.x = window.startX + deltaX;
                spineboy.y = window.startY + deltaY;
                
                params.posx = spineboy.x;
                params.posy = spineboy.y;
                
                posxController.updateDisplay();
                posyController.updateDisplay();
            }
        }

      })();



    </script>
  </body>
</html>